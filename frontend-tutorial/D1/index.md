---
next:
  link: ./D11.html
  text: D11. 枚举 模拟 算法复杂度
---

# D1. 算法基础

> 当代码从“能运行”进化到“高效优雅”，算法将成为你破解复杂问题的“终极武器”。你已经能用基础语法搭建程序框架，但如何让代码在亿万数据中“快如闪电”，如何用简洁逻辑解决看似无解的谜题？在这一章，我们将拆解算法的核心思维，让你的程序不仅“跑得通”，更要“跑得赢”！

## 你将学到：

- **算法思维入门**：破译“递归咒语”与“分治策略”，用“贪心”与“动态规划”破解背包问题、路径优化等经典谜题
- **时间与空间的博弈**：理解`O(n²)`与`O(log n)`的差距，学会用“大O表示法”预测代码的“体力消耗”
- **数据结构魔法**：用栈的“后进先出”实现回退功能，让队列的“先进先出”管理任务队列
- **调试玄学问题**：通过“边界条件”排查递归崩溃，用“状态转移表”梳理动态规划逻辑
- **从理论到实战**：用二分查找优化搜索效率，用冒泡排序理解算法迭代的底层逻辑

## 为什么重要？

- **解决“代码卡顿”顽疾**：当程序在百万数据前“罢工”，不再依赖“换台更大电脑”的无奈方案
- **面试通关秘籍**：掌握排序、查找等高频考点，用算法思维拆解复杂问题，拿下技术岗“入场券”
- **创造指数级效率**：用动态规划将“指数级爆炸”问题压缩为“多项式时间”，让计算机完成人类无法手动计算的挑战
- **培养工程师思维**：通过算法训练结构化拆解问题的能力，从“救火式编码”进化为“体系化设计”

## 学习提示：

- **实战三板斧**：
  1. **手动画图**：用纸笔模拟递归调用栈，追踪变量变化路径
  2. **表格推导**：用动态规划表逐行计算状态转移，验证最优解
  3. **极端测试**：用空数组、单元素、逆序数据等边界条件检验算法鲁棒性
- **牢记“木桶定律”**：算法效率由最慢的环节决定，优先优化瓶颈代码
- **递归调试口诀**：无终止条件必栈溢出，参数更新方向要“步步靠近基例”
- **动态规划心法**：先定义状态“dp[i]代表什么”，再追问“上一个状态如何转移而来”

## 突破算法的“黑箱”迷雾

有人说算法是门玄学——为什么同样的思路代码却天差地别？为什么递归能无限嵌套又突然崩溃？本章将用**系统化的方法论**和**工程化训练**，带你：
- 通过“分步执行”工具可视化冒泡排序的每轮交换
- 用“缓存备忘录”优化递归重复计算，让斐波那契数列从“指数爆炸”变“线性飞驰”
- 结合LeetCode实战，将理论转化为“解题肌肉记忆”

准备好用算法的“思维武器”征服代码世界的星辰大海了吗？下一屏，我们将从“时间复杂度”的底层逻辑开始，带你看清每个算法的“体力消耗”与“智慧结晶”！
